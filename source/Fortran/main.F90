    program main
    
    use mpi
    use decomp_2d
    use readWriteMat
    use timeIntegration
    use nseq
    use derivs
    
    implicit none
    
    ! Read parameters file generated by Matlab
    include 'parameters.F90'
    
    ! Declare variables for the matrices
    integer :: nDerivBlocksX, nDerivBlocksY, nDerivBlocksZ
    integer, dimension(:,:), allocatable :: derivBlocksX, derivBlocksY, derivBlocksZ
    integer :: derivnRHSx, filternRHSx, derivnRHSy, filternRHSy, derivnRHSz, filternRHSz
    
    real*8, dimension(:,:),   allocatable :: derivsAX, derivsBX, derivsCX, filterAX, filterBX, filterCX
    real*8, dimension(:,:,:), allocatable :: derivsRX, filterRX
    
    real*8, dimension(:,:),   allocatable :: derivsAY, derivsBY, derivsCY, filterAY, filterBY, filterCY
    real*8, dimension(:,:,:), allocatable :: derivsRY, filterRY
    
    real*8, dimension(:,:),   allocatable :: derivsAZ, derivsBZ, derivsCZ, filterAZ, filterBZ, filterCZ
    real*8, dimension(:,:,:), allocatable :: derivsRZ, filterRZ
    
    real*8 ,dimension(:,:),   allocatable :: derivsDX, derivsDY, derivsDZ, filterDX, filterDY, filterDZ
    integer :: periodicX, periodicY, periodicZ, filterX, filterY, filterZ
    
    integer :: neumannLength, neumann2Length
    real*8, dimension(:), allocatable :: neumannCoeffs, neumann2Coeffs
    
    ! Declare variables for the boundaries
    integer :: nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs ! Number of each type of boundary
    integer, dimension(:,:), allocatable :: iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs ! Index for each boundary
    real*8,  dimension(:),   allocatable :: vUd, vVd, vWd, vPd, vEd ! Value for Dirichlet conditions
    integer, dimension(:),   allocatable :: dUn, dVn, dWn, dPn, dEn ! Direction for Neumann conditions
    integer, dimension(:),   allocatable :: dUs, dVs, dWs, dPs, dEs ! Direction for null second derivative conditions
    
    integer :: cN ! Number of corners
    integer, dimension(:,:), allocatable :: cL, cD ! Location and direction for corners
    integer, dimension(:), allocatable :: cAdiabatic ! Adiabatic flag for corners
    
    ! Declare flow variables
    real*8,  dimension(:,:,:), allocatable :: U,V,W,R,E,Udot,Vdot,Wdot,Rdot,Edot
    real*8,  dimension(:,:,:), allocatable :: Ug,Vg,Wg,Rg,Eg,Udotg,Vdotg,Wdotg,Rdotg,Edotg
    logical, dimension(:,:,:), allocatable :: insideWall
    real*8,  dimension(:,:,:), allocatable :: Umean,Vmean,Wmean,Rmean,Emean
    real*8,  dimension(:,:,:), allocatable :: Unew,Vnew,Wnew,Rnew,Enew
    real*8,  dimension(5)                  :: maxChange, maxChangeL, minChange
    real*8,  dimension(:,:,:), allocatable :: SFD_X
    real*8,  dimension(:,:,:), allocatable :: SFD_Xg

    ! Declare domain decomposition variables
    integer :: ierror
    integer, dimension(:), allocatable :: sliceSizes, slicesJStarts, slicesJEnds, slicesKStarts, slicesKEnds
    
    ! Declare time stepping variables
    integer :: tstep, nSaveTemp, simulationDone, stepsUntilSaving
    real*8 :: t, dt
    real*8 :: CFLdt, CFL, UmaxL, VmaxL, WmaxL, Umax, Vmax, Wmax
    integer :: nTracked
    integer, dimension(:,:), allocatable :: indTracked
    real*8, dimension(5) :: trackedValues
    
    ! Declare rest of the variables
    integer :: i,j,k
    real*8 :: NaN
	logical :: stopDNS = .FALSE.

    
    ! INITIALIZE DOMAIN DECOMPOZITION
    call mpi_init(ierror)
    call decomp_2d_init(nx,ny,nz,p_row,p_col)
    
    ! Read matrices and boundaries files generated by Matlab
    include 'matrices.F90'
    include 'boundaryInfo.F90'
    
    ! IMPORT FLOW
    allocate(U(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(V(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(W(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(R(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(E(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))

    U = 0
    V = 0
    W = 0
    R = 0
    E = 0

    if(saveDerivs) then
        allocate(Udot(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Vdot(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Wdot(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Rdot(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Edot(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    
        Udot = 0
        Vdot = 0
        Wdot = 0
        Rdot = 0
        Edot = 0
    endif
    
    include 'importFlow.F90'
    
    ! APPLY BOUNDARIES
    call applyBoundCond(U,V,W,R,E,gamma,t, &
                & neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
                & nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
                & iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
                & vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
                & cN, cL, cD, cAdiabatic)
                
    ! INITIALIZE SFD
    if(SFD.gt.0) then ! If SFD changes along the domain, it is to be imported from a .mat
    
        allocate(sfd_X(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        
        select case(SFD)
        case(1)
            sfd_X = sfd_X_val
        
        case(2)
            if(nrank.eq.0) then! Import only in the root process
            
                allocate(sfd_Xg(nx,ny,nz))
                call readSFD(sfd_Xg)
                
                sfd_X = sfd_Xg(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))
                
                do i = 1,nproc-1
                    call MPI_SEND(sfd_Xg(xstart(1):xend(1),slicesJStarts(i):slicesJEnds(i),slicesKStarts(i):slicesKEnds(i)), sliceSizes(i), MPI_DOUBLE, i, 11,  MPI_COMM_WORLD, ierror)
                enddo
                
                deallocate(sfd_Xg)
                
            else ! If not root, receive data from root
                call MPI_RECV(sfd_X, xsize(1)*xsize(2)*xsize(3), MPI_DOUBLE, 0, 11,  MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierror)
            endif
        end select
    endif
    
    if(SFD.gt.0) then
    
        allocate(Umean(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Vmean(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Wmean(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Rmean(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
        allocate(Emean(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    
		if(resumeMeanFlow.eq.1) then
			include 'importMeanFlow.F90'
		else
			Umean = U
			Vmean = V
			Wmean = W
			Rmean = R
			Emean = E
		endif
    endif
    
    ! RUN TIME STEPPING
    simulationDone = 0
	
	select case (timeControl)
		case(1) !Continue the iteration count if the dt is fixed
			tstep = nSave
		case(2) !Reset the count if the dt is variable
			tstep = 0
	end select
    
    ! Allocate variables for next step
    allocate(Unew(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(Vnew(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(Wnew(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(Rnew(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    allocate(Enew(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)))
    
    Unew = 0
    Vnew = 0
    Wnew = 0
    Rnew = 0
    Enew = 0
    
    stepsUntilSaving = 0
    
    do while (simulationDone.eq.0)
    
        ! TIME CONTROL
        
        ! Get maximum velocity from all slices
        UmaxL = maxval(abs(U))
        VmaxL = maxval(abs(V))
        call MPI_Barrier(MPI_COMM_WORLD,ierror)
        call MPI_REDUCE(UmaxL,Umax,1,MPI_REAL8,MPI_MAX,0,MPI_COMM_WORLD,ierror)
        call MPI_REDUCE(VmaxL,Vmax,1,MPI_REAL8,MPI_MAX,0,MPI_COMM_WORLD,ierror)
        if (nz.gt.1) then ! For 3D
            WmaxL = maxval(abs(W))
            call MPI_REDUCE(WmaxL,Wmax,1,MPI_REAL8,MPI_MAX,0,MPI_COMM_WORLD,ierror)
        endif
        
        ! CFLdt is the CFL divided by dt
        if (nrank.eq.0) then
            if (nz.gt.1) then ! For 3D
                CFLdt = (1/Ma + Umax)*dxmin(1) + (1/Ma + Vmax)*dxmin(2) + (1/Ma + Wmax)*dxmin(3)
            else ! For 2D
                CFLdt = (1/Ma + Umax)*dxmin(1) + (1/Ma + Vmax)*dxmin(2)
                
            endif
        endif
        
        CALL MPI_BCAST(CFLdt, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD, ierror)
        
        ! Determine time step and check for saving and ending
        select case (timeControl)
            case (1) ! Fixed dt
                if (mod(tstep + 1,qtimesInt).eq.0) then
                    stepsUntilSaving = 0
                    nSave = tstep + 1
                else
                    stepsUntilSaving = 1
                endif
                dt = dtmax
                
                if ((tstep+1).ge.tmaxInt) then
                    simulationDone = 1
                endif
                
            case (2) ! Maximum CFL
            
                if(stepsUntilSaving.eq.0) then
                    dt = min(maxCFL/CFLdt,dtmax)
                    stepsUntilSaving = floor(qtimesReal/dt)+1
                    dt = qtimesReal/stepsUntilSaving
                    nSave = nSave + 1
                endif
                
                stepsUntilSaving = stepsUntilSaving-1
                
                
                if ((t+dt).ge.tmaxReal) then
                    simulationDone = 1
                endif
                
        end select
        
        CFL = dt*CFLdt
        
        ! Call stepping routine
        if (nz.eq.1) then
            select case(timeStepping)
                case (1) ! RK4
                    call RK4_2D(U,V,W,R,E,Unew,Vnew,Rnew,Enew, &
                            & t, dt, Re, Ma, Pr, gamma, T0, &
                            & nDerivBlocksX,nDerivBlocksY,derivBlocksX,derivBlocksY, &
                            & derivnRHSx,derivnRHSy, &
                            & derivsAX, derivsBX, derivsCX, derivsRX, &
                            & derivsAY, derivsBY, derivsCY, derivsRY, &
                            & derivsDX, derivsDY, &
                            & periodicX, periodicY, &
                            & neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
                            & nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
                            & iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
                            & vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
                            & cN, cL, cD, cAdiabatic)
                            
                case (2) ! EULER
                    call EULER_2D(U,V,W,R,E,Unew,Vnew,Rnew,Enew, &
                            & t, dt, Re, Ma, Pr, gamma, T0, &
                            & nDerivBlocksX,nDerivBlocksY,derivBlocksX,derivBlocksY, &
                            & derivnRHSx,derivnRHSy, &
                            & derivsAX, derivsBX, derivsCX, derivsRX, &
                            & derivsAY, derivsBY, derivsCY, derivsRY, &
                            & derivsDX, derivsDY, &
                            & periodicX, periodicY, &
                            & neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
                            & nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
                            & iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
                            & vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
                            & cN, cL, cD, cAdiabatic)
							
				case (3) ! SSPRK3
					call SSPRK3_2D(U,V,W,R,E,Unew,Vnew,Rnew,Enew, &
                            & t, dt, Re, Ma, Pr, gamma, T0, &
                            & nDerivBlocksX,nDerivBlocksY,derivBlocksX,derivBlocksY, &
                            & derivnRHSx,derivnRHSy, &
                            & derivsAX, derivsBX, derivsCX, derivsRX, &
                            & derivsAY, derivsBY, derivsCY, derivsRY, &
                            & derivsDX, derivsDY, &
                            & periodicX, periodicY, &
                            & neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
                            & nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
                            & iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
                            & vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
                            & cN, cL, cD, cAdiabatic)
            end select
            
        else
            select case(timeStepping)
                case (1) ! RK4
                    call RK4_3D(U,V,W,R,E,Unew,Vnew,Wnew,Rnew,Enew, &
                            & t, dt, Re, Ma, Pr, gamma, T0, &
                            & nDerivBlocksX,nDerivBlocksY,nDerivBlocksZ,derivBlocksX,derivBlocksY,derivBlocksZ, &
                            & derivnRHSx,derivnRHSy,derivnRHSz, &
                            & derivsAX, derivsBX, derivsCX, derivsRX, &
                            & derivsAY, derivsBY, derivsCY, derivsRY, &
                            & derivsAZ, derivsBZ, derivsCZ, derivsRZ, &
                            & derivsDX, derivsDY, derivsDZ, &
                            & periodicX, periodicY, periodicZ, &
                            & neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
                            & nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
                            & iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
                            & vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
                            & cN, cL, cD, cAdiabatic)
                            
                case (2) ! EULER
                    call EULER_3D(U,V,W,R,E,Unew,Vnew,Wnew,Rnew,Enew, &
                            & t, dt, Re, Ma, Pr, gamma, T0, &
                            & nDerivBlocksX,nDerivBlocksY,nDerivBlocksZ,derivBlocksX,derivBlocksY,derivBlocksZ, &
                            & derivnRHSx,derivnRHSy,derivnRHSz, &
                            & derivsAX, derivsBX, derivsCX, derivsRX, &
                            & derivsAY, derivsBY, derivsCY, derivsRY, &
                            & derivsAZ, derivsBZ, derivsCZ, derivsRZ, &
                            & derivsDX, derivsDY, derivsDZ, &
                            & periodicX, periodicY, periodicZ, &
                            & neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
                            & nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
                            & iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
                            & vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
                            & cN, cL, cD, cAdiabatic)
							
							
                case (3) ! SSPRK3
                    call SSPRK3_3D(U,V,W,R,E,Unew,Vnew,Wnew,Rnew,Enew, &
                            & t, dt, Re, Ma, Pr, gamma, T0, &
                            & nDerivBlocksX,nDerivBlocksY,nDerivBlocksZ,derivBlocksX,derivBlocksY,derivBlocksZ, &
                            & derivnRHSx,derivnRHSy,derivnRHSz, &
                            & derivsAX, derivsBX, derivsCX, derivsRX, &
                            & derivsAY, derivsBY, derivsCY, derivsRY, &
                            & derivsAZ, derivsBZ, derivsCZ, derivsRZ, &
                            & derivsDX, derivsDY, derivsDZ, &
                            & periodicX, periodicY, periodicZ, &
                            & neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
                            & nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
                            & iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
                            & vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
                            & cN, cL, cD, cAdiabatic)
            end select
            
        endif
		
        ! Apply anti-aliasing filter
        if(nz.eq.1) then
            call applyFilters2D(Unew,Vnew,Rnew,Enew,FilterX,FilterY, &
                            & nDerivBlocksX,nDerivBlocksY,derivBlocksX,derivBlocksY, &
                            & filternRHSx,filternRHSy, &
                            & filterAX, filterBX, filterCX, filterRX, &
                            & filterAY, filterBY, filterCY, filterRY, &
                            & filterDX, filterDY, &
                            & periodicX, periodicY, &
							& dt/FilterCharTime)
                            
        else
            call applyFilters3D(Unew,Vnew,Wnew,Rnew,Enew,FilterX,FilterY,FilterZ, &
                            & nDerivBlocksX,nDerivBlocksY,nDerivBlocksZ,derivBlocksX,derivBlocksY,derivBlocksZ, &
                            & filternRHSx,filternRHSy,filternRHSz, &
                            & filterAX, filterBX, filterCX, filterRX, &
                            & filterAY, filterBY, filterCY, filterRY, &
                            & filterAZ, filterBZ, filterCZ, filterRZ, &
                            & filterDX, filterDY, filterDZ, &
                            & periodicX, periodicY, periodicZ, &
							& dt/FilterCharTime)
        endif
		
		
        ! Apply SFD
        if(SFD.gt.0) then
			if(SFD_Delta.gt.0) then
				Umean = Umean + dt/SFD_Delta*(Unew-Umean)
				Vmean = Vmean + dt/SFD_Delta*(Vnew-Vmean)
				Rmean = Rmean + dt/SFD_Delta*(Rnew-Rmean)
				Emean = Emean + dt/SFD_Delta*(Enew-Emean)
			endif
		
            Unew = Unew - dt*SFD_X*(Unew-Umean)
            Vnew = Vnew - dt*SFD_X*(Vnew-Vmean)
            Rnew = Rnew - dt*SFD_X*(Rnew-Rmean)
            Enew = Enew - dt*SFD_X*(Enew-Emean)

            if(nz.gt.1) then
				if(SFD_Delta.gt.0) then
					Wmean = Wmean + dt/SFD_Delta*(Wnew-Wmean)
				endif
				Wnew = Wnew - dt*SFD_X*(Wnew-Wmean)
            endif
        
        endif
		
		! Apply boundary conditions
        call applyBoundCond(Unew,Vnew,Wnew,Rnew,Enew,gamma,t + dt, &
				& neumannLength, neumann2Length, neumannCoeffs, neumann2Coeffs, &
				& nUd, nVd, nWd, nPd, nEd, nUn, nVn, nWn, nPn, nEn, nUs, nVs, nWs, nPs, nEs, &
				& iUd, iVd, iWd, iPd, iEd, iUn, iVn, iWn, iPn, iEn, iUs, iVs, iWs, iPs, iEs, &
				& vUd, vVd, vWd, vPd, vEd, dUn, dVn, dWn, dPn, dEn, dUs, dVs, dWs, dPs, dEs, &
				& cN, cL, cD, cAdiabatic)
				
				
        ! Get maximum value changes in the domain
        maxChangeL(1) = maxval(abs(Unew - U))
        maxChangeL(2) = maxval(abs(Vnew - V))
        maxChangeL(3) = maxval(abs(Wnew - W))
        maxChangeL(4) = maxval(abs(Rnew - R))
        maxChangeL(5) = maxval(abs(Enew - E))
        
        call MPI_REDUCE(maxChangeL,maxChange,5,MPI_REAL8,MPI_MAX,0,MPI_COMM_WORLD,ierror)
        
        ! Update time
        tstep = tstep + 1
        t = t + dt
        
        ! Write to screen
        if(nrank.eq.0) then
            write(*,*) ''
            write(*,'(A9,I10,A13,EN14.6E1,A7,ES10.5E1,A8,F8.5)') 'Step = ', tstep, 'Time = ', t, 'dt = ', dt, 'CFL = ', CFL
            write(*,'(3(A13,ES10.4))') 'U change = ', maxChange(1), 'V change = ', maxChange(2), 'W change = ', maxChange(3)
            write(*,'(2(A13,ES10.4))') 'R change = ', maxChange(4), 'E change = ', maxChange(5)
            
            ! Check if flow has diverged
            if((any(isnan(maxChange))).OR.(sum(maxChange).eq.0)) then
				stopDNS = .TRUE.
                write(*,*) 'Flow has diverged, stopping'
            endif
        endif
		
		! Stop code if flow has diverged and save results
		CALL MPI_BCAST(stopDNS, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierror)
		if(stopDNS) then
			nSave = -1
			include 'exportFlow.F90'
			call decomp_2d_finalize
			call MPI_FINALIZE(ierror)
			stop
		endif
		
        if(saveDerivs) then
            Udot = (Unew-U)/dt
            Vdot = (Vnew-V)/dt
            Wdot = (Wnew-W)/dt
            Rdot = (Rnew-R)/dt
            Edot = (Enew-E)/dt
        endif

		! Update flow
		U = Unew
        V = Vnew
        R = Rnew
        E = Enew
        if (nz.gt.1) then
            W = Wnew
        endif
        
        ! Write to log file
        if ((mod(tstep,logAll).eq.0).or.(stepsUntilSaving.eq.0)) then
            if(nrank.eq.0) then! Run only in the root process
                open(2,file='../log.txt', status='unknown', access='append')
                    if (stepsUntilSaving.eq.0) then
                        nSaveTemp = nSave
                    else
                        nSaveTemp = 0
                    endif
                    write(2,'(I10,A1,I10,A1,ES13.8E1,A1,ES10.5E1,A1,F8.5,5(A1,ES10.4E2))',advance='no') nSaveTemp, char(9), tStep, char(9), t, char(9), dt, char(9), cfl, char(9), maxChange(1), char(9), maxChange(2), char(9), maxChange(3), char(9), maxChange(4), char(9), maxChange(5)
                    
                    do i = 1,nTracked
                        ! If the tracked node is in the root process, gather it
                        if((indTracked(i,2).ge.xstart(2)).and.(indTracked(i,2).le.xend(2)).and.(indTracked(i,3).ge.xstart(3)).and.(indTracked(i,3).le.xend(3))) then
                            trackedValues(1) = U(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                            trackedValues(2) = V(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                            trackedValues(3) = W(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                            trackedValues(4) = R(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                            trackedValues(5) = E(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                        else ! If not, receive it
                            call MPI_RECV(trackedValues, 5, MPI_DOUBLE, MPI_ANY_SOURCE, 11+i,  MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierror)
                        endif
						
						if (trackedNorm.ne.0) then
							trackedValues(4) = trackedValues(4)-1
							trackedValues(5) = trackedValues(5)/trackedNorm-1
						endif
						
						do j = 1,5
							if (trackedValues(j).eq.0) then
								write(2,'(A1,A1)',advance='no') char(9), "0"
							else
								write(2,'(A1,ES15.8E2)',advance='no') char(9), trackedValues(j)
							endif
						enddo
						
                    enddo
                    
                    write(2,*) ''
                close(2)
                
            else ! If this is not root, send data on the tracked values
                do i = 1,nTracked
                    if((indTracked(i,2).ge.xstart(2)).and.(indTracked(i,2).le.xend(2)).and.(indTracked(i,3).ge.xstart(3)).and.(indTracked(i,3).le.xend(3))) then
                        trackedValues(1) = U(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                        trackedValues(2) = V(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                        trackedValues(3) = W(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                        trackedValues(4) = R(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                        trackedValues(5) = E(indTracked(i,1),indTracked(i,2),indTracked(i,3))
                        call MPI_SEND(trackedValues, 5, MPI_DOUBLE, 0, 11+i,  MPI_COMM_WORLD, ierror)
                    endif
                enddo
            endif
        endif
        
        if (stepsUntilSaving.eq.0) then
            include 'exportFlow.F90'
			
			if(SFD.gt.0) then
				if(SFD_Delta.gt.0) then
					include 'exportMeanFlow.F90'
				endif
			endif
			
        endif
    
    end do
    
    ! Clean up
    call decomp_2d_finalize
    call MPI_FINALIZE(ierror)
    
    end program
